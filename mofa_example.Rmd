---
title: "MOFA"
author: "Mar Garcia-Aloy"
output: 
  BiocStyle::html_document:
    toc: true
    number_sections: false
    toc_float: true
---

```{r startpoint, include = FALSE}
startpoint <- Sys.time()
```

En este documento voy a intentar reproducir el ejemplo que se incluye en 
la descripción del paquete "MOFA", cuyas siglas significan "análisis de factores multi-ómicos" (del inglés 
“Multi‐Omics Factor Analysis"). 
Se trata de un método computacional para el descubrimiento no supervisado de las principales fuentes de variación en diversos conjuntos de datos multi-ómicos medidos en las mismas muestras.  
MOFA infiere un conjunto de factores latentes que captan las fuentes de variabilidad biológicas y técnicas.  
Los factores pueden ser compartidos por múltiples modalidades de datos o pueden ser específicos de un tipo de datos.  
Los factores calculados permiten realizar diversos análisis posteriores, como la identificación de subgrupos de muestras, la imputación de datos y la detección de muestras "outliers".  
El modelo maneja con flexibilidad los diferentes tipos de datos y los valores "missing". En este sentido, MOFA está diseñado para hacer frente a aquellos estudios en los que no todas las muestras han sido sometidas a los experimentos de todas las técnicas ómicas utilizadas.


# Principios del método MOFA

MOFA parte de `M` matrices de datos `Y` de dimensiones `N` x `Dm`, donde `N` es el número de muestras y `Dm` el número de varaibles para la matriz `m`.

MOFA crea un modelo formulado en un marco probabilístico bayesiano que considera los factores `Z` (que son comunes para todas las matrices de datos), el peso `Wm` que se da a cada una de las matrices y el ruido residual `Em`. 
  
MOFA regulariza el peso de las matrices para que el modelo pueda descifrar la variación existente entre los diversos conjuntos de datos y producir factores interpretables. Utiliza una regularización de dos niveles: el primer nivel fomenta la dispersión de la visión y de los factores, permitiendo así identificar directamente qué factor está activo en cada visión. El segundo nivel fomenta la dispersión de las variables, lo que suele dar lugar a un pequeño número de variables con pesos activos.  
  
En primer lugar, MOFA realiza la caracterización e interpretación de factores latentes. Después de que un modelo ha sido construido, se desentraña la variación explicada por cada factor en cada matriz. Posteriormente, cada factor se define mediante tres análisis complementarios:    
    
   - *Ordenación de las muestras en el espacio factorial*: Visualizar una representación de baja dimensión de los principales impulsores de la heterogeneidad de las muestras.     
   - *Inspección de las variables con mayor peso*: los "loadings" pueden dar una idea del proceso biológico que subyace a la heterogeneidad capturada por un factor latente. Debido a las diferencias de escala entre los análisis, los pesos de las diferentes matrices de datos no son directamente comparables. Para simplificar, escalamos cada vector de peso por su valor absoluto.  
   - *Análisis de enriquecimiento del conjunto de variables*: Combinar la señal de conjuntos de variables funcionalmente relacionades (por ejemplo, conjuntos de genes) para conducir a una anotación basada en un conjunto de variables Por defecto, utilizamos una prueba t paramétrica que compara las medias del conjunto en primer plano (los pesos de las variables que pertenecen a un conjunto `G`) y del conjunto en segundo plano (los pesos de las variables que no pertenecen al conjunto `G`).  



# Descripción del ejemplo  

Aplicamos la MOFA a una cohorte de 200 muestras de pacientes de leucemia linfocítica crónica (CLL, del inglés "chronic lymphocytic leukaemia"), de las cuales se dispone de datos sobre mutaciones somáticas (combinación de análisis de secuenciación de un panel de genes diana (*target sequencing*) y de la región codificante del mismo (*whole exmoe sequencing*), expresión de ARN (RNA-Seq), metilación de ADN (tecnología Illumina) y respuestas de fármacos ex vivo (ensayos ATP basados en CellTiter-Glo). Cabe destacar que casi el 40% de las 200 muestras se perfilaron con algunos, pero no con todas las técnicas ómicas.  


# Preparación de los datos

Existen dos opciones para importar los datos:  
  
   - Opción 1: enfoque de "base R" utilizando una lista de matrices  
   - Opción 2: Enfoque de "Bioconductor" utilizando la estructura de "MultiAssayExperiment"  

## Aproximación "base R"

Básicamente se debe aportar una lista de matrices donde las variables estén en las filas y las muestras en las columnas.  
Las muestras tienen que estar alineadas y los valores o análisis "missing" deben estar rellenados con "NAs".  

```{r}
library(MOFA)
library(MOFAdata)
data("CLL_data")
MOFAobject <- createMOFAobject(CLL_data)
```


## Aproximación "Bioconductor"

Es necesario proveer o crear un objeto de tipo `MultiAssayExperiment` y luego usarlo para constribuir el objeto `MOFA`.  
Por ejemplo, se puede empezar con una lista de matrices donde las variables estén en las filas y las muestras en las columnas.

```{r}
library(MultiAssayExperiment)

# Load data
# import list with mRNA, Methylation, Drug Response and Mutation data. 
data("CLL_data") 

# check dimensionalities, samples are columns, features are rows
lapply(CLL_data, dim) 

# Load sample metadata: Sex and Diagnosis
data("CLL_covariates")
head(CLL_covariates)

# Create MultiAssayExperiment object 
mae_CLL <- MultiAssayExperiment(
  experiments = CLL_data, 
  colData = CLL_covariates
)

# Build the MOFA object
MOFAobject <- createMOFAobject(mae_CLL)
MOFAobject
```


## Visión general de los datos

La función `plotDataOverview` puede utilizarse para obtener una visión general de los datos. Para cada muestra indica en qué matrices hay datos disponibles. Las filas son las diferentes matrices y las columnas son las muestras. Los valores que faltan se indican con una barra gris.

# Construcción del modelo

El siguiente paso es ajustar el modelo. Esta parte del "pipeline" se implementa en Python.

## Definición de parámetros

### Parámetros de los datos

Las opciones más importantes que el usuario debe definir son:  
  
  - **scaleViews**: indicar si se deben escalar los datos para presentar "unit variance". Mientras la escala de los diferentes conjuntos de datos no sea demasiado alta, esto no es necesario. El valor por defecto es `FALSE`.  
  - **removeIncompleteSamples**: indicar si se deben eliminar las muestras por las que no se disponen de todos los datos ómicos. El modelo puede hacer frente a los ensayos que faltan, por lo que esta opción no es necesaria. El valor por defecto es `FALSE`.  

```{r}
DataOptions <- getDefaultDataOptions()
DataOptions 
```


### Parámetros del modelo

Las opciones más importantes a definir en los modelos son:  
  
  - **numFactors**: número de factores (por defecto es igual a la mitad del número de muestras). Por defecto, el modelo solo eliminará un factor si este explica exactamente una varianza 0 en los datos. El usuario puede aumentar este umbral en la variación mínima explicada ajustando `TrainOptions$dropFactorThreshold` a un valor superior a cero.  
  - **likelihoods**: verosimilitud para cada matriz. Los autores recomiendan gaussiano para los datos continuos, bernoulli para los datos binarios y poisson para los datos de conteo. Por defecto, el modelo intenta deducirlo de forma autónoma a partir de los datos.  
  - **sparsity**: inidcar si se quiere usar "sparsity", lo cual facilita la interpretación de los resultados. El valor por defecto es `TRUE`.  

```{r}
ModelOptions <- getDefaultModelOptions(MOFAobject)
ModelOptions$numFactors <- 25
ModelOptions
```


### Parámetros para el entrenamiento del modelo

Las opciones más importantes para el entrenamiento del modelo son:  
  
  - **maxiter**: número máximo de iteraciones. Lo ideal sería que fuera lo suficientemente grande y que utilizara el criterio de convergencia `TrainOptions$tolerance`.  
  - **tolerance**: umbral de convergencia basado en el cambio del límite inferior de las pruebas. Para una primera eploración se puede utilizar un valor entre 1.0 y 0.1, pero para un modelo "final" recomendamos un valor de 0.01.  
  - **DropFactorThreshold**: hiperparámetro para aprender automáticamente el número de factores basados en un criterio explícito de variación mínima. Se eliminarán los factores que expliquen una fracción de variación inferior a `DropFactorThreshold` en todas las matrices Por ejemplo, un valor de 0.01 significa que se descartarán los factores que expliquen menos del 1% de la variación en todas las matrices. Por defecto es cero, lo que significa que todos los factores se mantienen a menos que no expliquen ninguna variación.
  
```{r}
TrainOptions <- getDefaultTrainOptions()

# Automatically drop factors that explain less than 2% of variance in all omics
TrainOptions$DropFactorThreshold <- 0.02

TrainOptions$seed <- 2017

TrainOptions
```


## Preparación del modelo

La función `prepareMOFA` ejecuta una serie de verificaciones internas y completa las secciones referentes a `DataOptions`, `TrainOptions` y `ModelOptions` del objeto `MOFAobjet`.  

```{r}
MOFAobject <- prepareMOFA(
  MOFAobject, 
  DataOptions = DataOptions,
  ModelOptions = ModelOptions,
  TrainOptions = TrainOptions
)
```

Opcionalmente, podemos hacer una regresión con algunas covariables (técnicas) antes del entrenamiento, usando un simple modelo lineal. Por ejemplo, aquí podemos elegir eliminar el efecto del sexo. Idealmente, todas las fuentes de variación no deseadas deben ser eliminadas a priori del modelo. La razón es que, si existen factores técnicos fuertes, el modelo se "centrará" en captar la variabilidad impulsada por los factores técnicos, y podrían pasarse por alto pequeñas fuentes de variabilidad biológica.

```{r}
# MOFAobject <- regressCovariates(
#   object = MOFAobject,
#   views = c("Drugs","Methylation","mRNA"),
#   covariates = MOFAobject@InputData$Gender
# )
```

## Ejecución del modelo

Ahora estamos listos para entrenar el `MOFAobjet`, lo cual se hace con la función `runMOFA`. 

```{r, eval=FALSE}
library(reticulate)
use_python("C:/Users/lenovo/Documents/R/win-library/4.0/reticulate/python", required = TRUE)
use_condaenv("r-reticulate", required = TRUE)
MOFAobject <- runMOFA(MOFAobject)
```


# Interpretación de los resultados

MOFA identificó las principales dimensiones de la heterogeneidad de la enfermedad, incluido el estado de la región de la cadena pesada de inmunoglobulinas, la trisomía del cromosoma 12 y los factores impulsores previamente subestimados, como la respuesta al estrés oxidativo.  
En una aplicación a la Leucemia Linfocítica Crónica, MOFA descubre un pequeño espacio dimensional que incluye marcadores clínicos conocidos y ejes de variación subestimados como el estrés oxidativo.  
  
En una segunda aplicación, utilizamos MOFA para analizar datos multi-ómicos de una sola célula, identificando cambios transcripcionales y epigenéticos coordinados a lo largo de la diferenciación celular.  
En una aplicación a los perfiles multi-ómicos de células individuales, MOFA recupera las trayectorias de diferenciación e identifica la variación coordinada entre el transcriptoma y el epigenoma.



# Session information

```{r session}
Sys.time()-startpoint
devtools::session_info()
```
